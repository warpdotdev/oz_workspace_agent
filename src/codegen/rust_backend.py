"""Rust backend: IR -> Rust code.

Transpiles Veritas IR to Rust code, leveraging Rust's ownership system
to implement Veritas semantics.
"""

from typing import Dict, List, Set, Optional
from ..ir.ir import *
from ..ast.types import Effect, EffectKind


class RustBackend:
    """Generates Rust code from Veritas IR."""
    
    # Mapping of Veritas builtins to Rust macros/functions
    BUILTIN_MACROS = {
        'println': 'println!',
        'print': 'print!',
        'eprintln': 'eprintln!',
        'eprint': 'eprint!',
        'format': 'format!',
        'panic': 'panic!',
        'assert': 'assert!',
        'debug_assert': 'debug_assert!',
        'vec': 'vec!',
    }
    
    def __init__(self):
        self.indent_level = 0
        self.branded_types: Set[str] = set()
    
    def generate(self, module: IRModule) -> str:
        """Generate Rust code from IR module."""
        lines = []
        
        # Add standard imports
        lines.append("// Generated by Veritas compiler")
        lines.append("// This code transpiles to Rust, preserving Veritas semantics")
        lines.append("")
        lines.append("#![allow(unused_variables, unused_mut, dead_code)]")
        lines.append("")
        
        # Generate type definitions
        for name, ty in module.types.items():
            type_code = self._generate_type_def(name, ty)
            if type_code:
                lines.append(type_code)
                lines.append("")
        
        # Generate functions
        for func in module.functions.values():
            func_code = self._generate_function(func)
            lines.append(func_code)
            lines.append("")
        
        return "\n".join(lines)
    
    def _generate_type_def(self, name: str, ty: IRType) -> Optional[str]:
        """Generate Rust type definition."""
        if ty.kind == IRTypeKind.STRUCT:
            return self._generate_struct_def(name, ty)
        elif ty.kind == IRTypeKind.ENUM:
            return self._generate_enum_def(name, ty)
        elif ty.kind == IRTypeKind.BRANDED:
            return self._generate_branded_type_def(name, ty)
        return None
    
    def _generate_struct_def(self, name: str, ty: IRType) -> str:
        """Generate Rust struct definition."""
        lines = [f"#[derive(Clone, Debug)]"]
        lines.append(f"pub struct {name} {{")
        
        for field_name, field_type in ty.fields:
            rust_type = self._type_to_rust(field_type)
            lines.append(f"    pub {field_name}: {rust_type},")
        
        lines.append("}")
        return "\n".join(lines)
    
    def _generate_enum_def(self, name: str, ty: IRType) -> str:
        """Generate Rust enum definition."""
        # For now, generate a basic enum
        lines = [f"#[derive(Clone, Debug)]"]
        lines.append(f"pub enum {name} {{")
        lines.append("    // TODO: Add variants")
        lines.append("}")
        return "\n".join(lines)
    
    def _generate_branded_type_def(self, name: str, ty: IRType) -> str:
        """Generate Rust newtype wrapper for branded type."""
        self.branded_types.add(name)
        inner_type = self._type_to_rust(ty.inner)
        
        lines = [
            f"#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
            f"pub struct {name}(pub {inner_type});",
            "",
            f"impl {name} {{",
            f"    pub fn new(value: {inner_type}) -> Self {{",
            f"        {name}(value)",
            f"    }}",
            f"    ",
            f"    pub fn into_inner(self) -> {inner_type} {{",
            f"        self.0",
            f"    }}",
            f"}}"
        ]
        return "\n".join(lines)
    
    def _generate_function(self, func: IRFunction) -> str:
        """Generate Rust function definition."""
        lines = []
        
        # Function signature
        params_str = ", ".join(
            f"{param.name}: {self._type_to_rust(param.type)}"
            for param in func.params
        )
        
        return_type = self._type_to_rust(func.return_type)
        return_str = f" -> {return_type}" if func.return_type.kind != IRTypeKind.VOID else ""
        
        lines.append(f"pub fn {func.name}({params_str}){return_str} {{")
        
        # Generate function body
        self.indent_level = 1
        
        # Declare locals
        for local in func.locals.values():
            rust_type = self._type_to_rust(local.type)
            lines.append(f"{self._indent()}let mut {local.name}: {rust_type};")
        
        # Generate blocks in order
        if func.entry_block:
            visited = set()
            self._generate_blocks_ordered(func, func.entry_block, visited, lines)
        
        lines.append("}")
        self.indent_level = 0
        
        return "\n".join(lines)
    
    def _generate_blocks_ordered(self, func: IRFunction, block_label: str, visited: Set[str], lines: List[str]):
        """Generate blocks in execution order."""
        if block_label in visited:
            return
        
        visited.add(block_label)
        block = func.get_block(block_label)
        if not block:
            return
        
        # Add block label if not entry block
        if block_label != func.entry_block:
            lines.append(f"{self._indent()}// {block_label}")
        
        # Generate instructions
        for instr in block.instructions:
            instr_code = self._generate_instruction(instr)
            if instr_code:
                lines.append(f"{self._indent()}{instr_code}")
        
        # Visit successors
        for succ in block.successors:
            if succ not in visited:
                self._generate_blocks_ordered(func, succ, visited, lines)
    
    def _generate_instruction(self, instr: IRInstruction) -> Optional[str]:
        """Generate Rust code for IR instruction."""
        if instr.opcode == IROpcode.ALLOC:
            # Allocation is handled by local declarations
            return None
        
        elif instr.opcode == IROpcode.LOAD:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = {instr.operands[0].name};"
            return None
        
        elif instr.opcode == IROpcode.STORE:
            if len(instr.operands) >= 2:
                return f"{instr.operands[0].name} = {instr.operands[1].name};"
            return None
        
        elif instr.opcode == IROpcode.MOVE:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = {instr.operands[0].name};"
            return None
        
        elif instr.opcode == IROpcode.BORROW:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = &{instr.operands[0].name};"
            return None
        
        elif instr.opcode == IROpcode.BORROW_MUT:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = &mut {instr.operands[0].name};"
            return None
        
        elif instr.opcode in [IROpcode.ADD, IROpcode.SUB, IROpcode.MUL, IROpcode.DIV, IROpcode.MOD]:
            op_map = {
                IROpcode.ADD: "+",
                IROpcode.SUB: "-",
                IROpcode.MUL: "*",
                IROpcode.DIV: "/",
                IROpcode.MOD: "%",
            }
            if len(instr.operands) >= 2:
                op = op_map[instr.opcode]
                return f"let {instr.result.name} = {instr.operands[0].name} {op} {instr.operands[1].name};"
            return None
        
        elif instr.opcode == IROpcode.NEG:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = -{instr.operands[0].name};"
            return None
        
        elif instr.opcode == IROpcode.NOT:
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = !{instr.operands[0].name};"
            return None
        
        elif instr.opcode in [IROpcode.EQ, IROpcode.NE, IROpcode.LT, IROpcode.GT, IROpcode.LE, IROpcode.GE]:
            op_map = {
                IROpcode.EQ: "==",
                IROpcode.NE: "!=",
                IROpcode.LT: "<",
                IROpcode.GT: ">",
                IROpcode.LE: "<=",
                IROpcode.GE: ">=",
            }
            if len(instr.operands) >= 2:
                op = op_map[instr.opcode]
                return f"let {instr.result.name} = {instr.operands[0].name} {op} {instr.operands[1].name};"
            return None
        
        elif instr.opcode in [IROpcode.AND, IROpcode.OR, IROpcode.XOR]:
            op_map = {
                IROpcode.AND: "&&",
                IROpcode.OR: "||",
                IROpcode.XOR: "^",
            }
            if len(instr.operands) >= 2:
                op = op_map[instr.opcode]
                return f"let {instr.result.name} = {instr.operands[0].name} {op} {instr.operands[1].name};"
            return None
        
        elif instr.opcode == IROpcode.CALL:
            # Handle constant arguments
            args = []
            for op in instr.operands:
                if op.kind == IRValueKind.CONSTANT and op.constant_value is not None:
                    if op.type.kind == IRTypeKind.STRING:
                        args.append(f"\"{op.constant_value}\"")
                    else:
                        args.append(str(op.constant_value))
                else:
                    args.append(op.name)
            args_str = ", ".join(args)
            
            # Map builtin functions to Rust macros
            func_name = instr.function_name
            if func_name in self.BUILTIN_MACROS:
                rust_func = self.BUILTIN_MACROS[func_name]
                # Macros like println! don't return values we can bind
                return f"{rust_func}({args_str});"
            
            if instr.result:
                return f"let {instr.result.name} = {func_name}({args_str});"
            else:
                return f"{func_name}({args_str});"
        
        elif instr.opcode == IROpcode.RETURN:
            if len(instr.operands) > 0:
                return f"return {instr.operands[0].name};"
            else:
                return "return;"
        
        elif instr.opcode == IROpcode.BR:
            # Rust doesn't have explicit goto, so we use labels (handled elsewhere)
            return None
        
        elif instr.opcode == IROpcode.BR_COND:
            # Conditional branches are handled as if-else
            if len(instr.operands) > 0 and instr.label:
                return f"if {instr.operands[0].name} {{"
            return None
        
        elif instr.opcode == IROpcode.STRUCT_NEW:
            # TODO: Generate struct initialization
            return None
        
        elif instr.opcode == IROpcode.STRUCT_GET:
            if len(instr.operands) > 0 and instr.field_name:
                return f"let {instr.result.name} = {instr.operands[0].name}.{instr.field_name};"
            return None
        
        elif instr.opcode == IROpcode.STRUCT_SET:
            if len(instr.operands) >= 2 and instr.field_name:
                return f"{instr.operands[0].name}.{instr.field_name} = {instr.operands[1].name};"
            return None
        
        elif instr.opcode == IROpcode.TUPLE_GET:
            if len(instr.operands) > 0 and instr.index is not None:
                return f"let {instr.result.name} = {instr.operands[0].name}.{instr.index};"
            return None
        
        elif instr.opcode == IROpcode.ARRAY_GET:
            if len(instr.operands) >= 2:
                return f"let {instr.result.name} = {instr.operands[0].name}[{instr.operands[1].name}];"
            return None
        
        elif instr.opcode == IROpcode.ARRAY_SET:
            if len(instr.operands) >= 3:
                return f"{instr.operands[0].name}[{instr.operands[1].name}] = {instr.operands[2].name};"
            return None
        
        elif instr.opcode == IROpcode.CAST:
            if len(instr.operands) > 0 and instr.type:
                rust_type = self._type_to_rust(instr.type)
                return f"let {instr.result.name} = {instr.operands[0].name} as {rust_type};"
            return None
        
        elif instr.opcode == IROpcode.BRAND:
            # Apply brand by wrapping in newtype
            if len(instr.operands) > 0 and instr.result:
                brand_name = instr.result.type.name
                return f"let {instr.result.name} = {brand_name}::new({instr.operands[0].name});"
            return None
        
        elif instr.opcode == IROpcode.UNBRAND:
            # Remove brand by extracting inner value
            if len(instr.operands) > 0:
                return f"let {instr.result.name} = {instr.operands[0].name}.into_inner();"
            return None
        
        else:
            return f"// TODO: {instr.opcode.name}"
    
    def _type_to_rust(self, ty: IRType) -> str:
        """Convert IR type to Rust type string."""
        if ty.kind == IRTypeKind.VOID:
            return "()"
        elif ty.kind == IRTypeKind.BOOL:
            return "bool"
        elif ty.kind == IRTypeKind.I8:
            return "i8"
        elif ty.kind == IRTypeKind.I16:
            return "i16"
        elif ty.kind == IRTypeKind.I32:
            return "i32"
        elif ty.kind == IRTypeKind.I64:
            return "i64"
        elif ty.kind == IRTypeKind.I128:
            return "i128"
        elif ty.kind == IRTypeKind.U8:
            return "u8"
        elif ty.kind == IRTypeKind.U16:
            return "u16"
        elif ty.kind == IRTypeKind.U32:
            return "u32"
        elif ty.kind == IRTypeKind.U64:
            return "u64"
        elif ty.kind == IRTypeKind.U128:
            return "u128"
        elif ty.kind == IRTypeKind.F32:
            return "f32"
        elif ty.kind == IRTypeKind.F64:
            return "f64"
        elif ty.kind == IRTypeKind.CHAR:
            return "char"
        elif ty.kind == IRTypeKind.STRING:
            return "String"
        elif ty.kind == IRTypeKind.POINTER:
            inner = self._type_to_rust(ty.inner) if ty.inner else "i32"
            if ty.mutable:
                return f"&mut {inner}"
            else:
                return f"&{inner}"
        elif ty.kind == IRTypeKind.STRUCT:
            return ty.name if ty.name else "StructType"
        elif ty.kind == IRTypeKind.ENUM:
            return ty.name if ty.name else "EnumType"
        elif ty.kind == IRTypeKind.BRANDED:
            return ty.name if ty.name else "BrandedType"
        elif ty.kind == IRTypeKind.TUPLE:
            if ty.fields:
                field_types = ", ".join(self._type_to_rust(f[1]) for f in ty.fields)
                return f"({field_types})"
            return "()"
        elif ty.kind == IRTypeKind.ARRAY:
            if ty.inner:
                elem_type = self._type_to_rust(ty.inner)
                if ty.size:
                    return f"[{elem_type}; {ty.size}]"
                else:
                    return f"Vec<{elem_type}>"
            return "Vec<i32>"
        else:
            return "i32"  # Default fallback
    
    def _indent(self) -> str:
        """Get indentation string."""
        return "    " * self.indent_level
